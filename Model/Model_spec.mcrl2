sort PlaneRequest = struct land | leave;
PlaneResponse = struct hold | redirect;
LocStatus = struct out_of_order | operational;
Location = struct gate1 | gate2 | taxiway | runway | air;
%Plane = struct one | two | three | four | five;
Plane = struct one | two;

act receiveRequest: Plane # PlaneRequest;
sendResponse: Plane # PlaneResponse;
assign: Location # Plane;
unassign: Location # Plane;
getSensorUpdate: Location # Plane;
getLocStatus: Location # LocStatus;
sendLocationStatus, receiveLocationStatus, commLocationStatus: Location # LocStatus;
sendAssignment, receiveAssignment, commAssignment: Location # Plane;

sendTWSensorUpdate, receiveTWSensorUpdate, commTWSensorUpdate: Location # Plane;
sendRWSensorUpdate, receiveRWSensorUpdate, commRWSensorUpdate: Location # Plane;

contactHelp;
print: Location;


% Assigned = true when assign occurs, and false when unassign occurs.

proc ProcessComms(locationStatus: Location -> LocStatus, occupiedStatus: Location -> Bool) = (
	sum L: Location, S:LocStatus . (
		receiveLocationStatus(L, S)
		. Communications(locationStatus = (locationStatus[L->S]))
	)
);

proc Communications(locationStatus: Location -> LocStatus, occupiedStatus: Location -> Bool) = (
	sum P: Plane, R: PlaneRequest . (
		receiveRequest(P, R)
		. (exists loc1, loc2: Location . locationStatus(loc1) == out_of_order && locationStatus(loc2) == out_of_order) -> (
			sendResponse(P, redirect)
			. Communications()
		)
		<> (exists loc1, loc2: Location . occupiedStatus(loc1) == true && occupiedStatus(loc2) == true ) -> (
			sendResponse(P, hold)
			. Communications()
		)
		<> (R == land) -> (
			assign(runway, P)
			. (
				sendAssignment(runway, P)
				+ ProcessComms(locationStatus, occupiedStatus) . sendAssignment(runway, P)
			) % make sure not stuck waiting
			. assign(taxiway, P)
			. ( sendAssignment(taxiway, P)
				+ ProcessComms(locationStatus, occupiedStatus) . sendAssignment(taxiway, P)
			) 
			. (occupiedStatus(gate1) == false) -> (
				assign(gate1, P)
				. ( sendAssignment(gate1, P)
				+ ProcessComms(locationStatus, occupiedStatus) . sendAssignment(gate1, P)
				)
				. Communications(occupiedStatus = (occupiedStatus[runway->true][taxiway->true][gate1->true]))
			)
			<> 
				assign(gate2, P)
				. ( sendAssignment(gate2, P)
				+ ProcessComms(locationStatus, occupiedStatus) . sendAssignment(gate2, P)
				)
				. Communications(occupiedStatus = (occupiedStatus[runway->true][taxiway->true][gate2->true]))	
		)
		<> (R == leave) -> (
			assign(runway, P)
			. ( sendAssignment(runway, P)
				+ ProcessComms(locationStatus, occupiedStatus) . sendAssignment(runway, P)
			)
			. assign(taxiway, P)
			. ( sendAssignment(taxiway, P)
				+ ProcessComms(locationStatus, occupiedStatus) . sendAssignment(taxiway, P)
			)
			. Communications(occupiedStatus = (occupiedStatus[runway->true][taxiway->true]))
		)
	)
	+ sum L: Location, S:LocStatus . (
		receiveLocationStatus(L, S)
		. Communications(locationStatus = (locationStatus[L->S]))
	) 
);

proc Roadway(road: Location, is_assigned: Bool, assigned_to: Plane, is_occupied: Bool, status: LocStatus) = (
	% runway has been assigned to a plane by central
	sum P: Plane . (
		receiveAssignment(road, P)
		% . Roadway(is_assigned = true, assigned_to = P)
		. Roadway(road, true, P, is_occupied, status)
	)
	% runway has become out of order or been repaired
	+ sum S: LocStatus . (
		getLocStatus(road, S)
		. sendLocationStatus(road, S)
		. Roadway(road, is_assigned, assigned_to, is_occupied, S)
	)
	% sensor update from runway
	+ sum P: Plane . (
		((road == runway) -> (
			% sum P: Plane . (
				receiveTWSensorUpdate(runway, P)
				% plane has left the runway
				. (is_assigned && P == assigned_to && is_occupied == true) -> (
					unassign(road, P)
					. Roadway(road,false, one, false, status)
				) <> (
				% otherwise, irrelevant
				Roadway(road, is_assigned, assigned_to, is_occupied, status)
			)
		) <> (road == taxiway) -> (
			% sum P: Plane . (
				receiveRWSensorUpdate(taxiway, P)
				% plane has left the taxiway
				. (is_assigned && P == assigned_to && is_occupied == true) -> (
					unassign(road, P)
					. Roadway(road, false, one, false, status)
				) <> (
				% otherwise, irrelevant
				Roadway(road, is_assigned, assigned_to, is_occupied, status)
			)
		)) + (getSensorUpdate(road, P)
		% plane on runway
		% . (L == road) -> (
		. (is_assigned == false || !(assigned_to == P)) -> (
			% unexpected plane
			contactHelp 
			% situation handled :)
			. Roadway(road, is_assigned, assigned_to, is_occupied, status)
		) <> (
			% expected plane
			% let neighbors know
			(road == runway) -> (
				% receiveTWSensorUpdate(runway, P)
				(sendRWSensorUpdate(taxiway, P)
				. Roadway(road, is_assigned, assigned_to, true, status))
				+ (receiveTWSensorUpdate(runway, P)
				. (is_assigned && P == assigned_to && is_occupied == true) -> (
					unassign(road, P)
					. Roadway(road, false, one, false, status)
				) <> (
				% otherwise, irrelevant
				Roadway(road, is_assigned, assigned_to, is_occupied, status)
			)
				)

				% . receiveTWSensorUpdate(runway, P)
				% + (receiveTWSensorUpdate(runway, P)
				% % plane has left the runway
				% . (is_assigned && P == assigned_to) -> (
				% 	unassign(road, P)
				% 	% . Roadway(is_assigned = false, assigned_to = one, is_occupied = false)
				% )  . sendRWSensorUpdate(taxiway, P))

			) <> (road == taxiway) -> (
				% sendTWSensorUpdate(runway, P)
				% + sendTWSensorUpdate(gate1, P)
				% + sendTWSensorUpdate(gate2, P)
				% receiveRWSensorUpdate(taxiway, P)
				% . (is_assigned && P == assigned_to && is_occupied) -> (
					% unassign(road, P)
				% . Roadway(is_assigned = false, assigned_to = one, is_occupied = false)
				% )22
				(sendTWSensorUpdate(runway, P)
				. Roadway(road, is_assigned, assigned_to, true, status))
				+ (receiveRWSensorUpdate(taxiway, P)
				. (is_assigned && P == assigned_to && is_occupied == true) -> (
					unassign(road, P)
					. Roadway(road, false, one, false, status)
				) <> (
				% otherwise, irrelevant
				Roadway(road, is_assigned, assigned_to, is_occupied, status)
			)
				)

				% + (receiveRWSensorUpdate(taxiway, P)
				% % plane has left the taxiway
				% . (is_assigned && P == assigned_to) -> (
				% 	unassign(road, P)
				% 	% . Roadway(is_assigned = false, assigned_to = one, is_occupied = false)
				% )  . sendTWSensorUpdate(runway, P))
			)
		))
	)
	% + (road == runway) -> (
	% 	sum P: Plane . (
	% 		receiveTWSensorUpdate(runway, P)
	% 		% plane has left the runway
	% 		. (is_assigned && P == assigned_to) -> (
	% 			unassign(road, P)
	% 			. Roadway(is_assigned = false, assigned_to = one, is_occupied = false)
	% 		)
	% 		% otherwise, irrelevant
	% 	)
	% ) <> (road == taxiway) -> (
	% 	sum P: Plane . (
	% 		receiveRWSensorUpdate(taxiway, P)
	% 		% plane has left the taxiway
	% 		. (is_assigned && P == assigned_to) -> (
	% 			unassign(road, P)
	% 			. Roadway(is_assigned = false, assigned_to = one, is_occupied = false)
	% 		)
	% 		% otherwise, irrelevant
	% 	)
	% )
);

% proc Taxiway(is_assigned: Bool, assigned_to: Plane, is_occupied: Bool, status: LocStatus) = (
% 	sum P: Plane . (
% 		receiveAssignment(taxiway, P)
% 		. Taxiway(is_assigned = true, assigned_to = P)
% 	)
% );

proc Gate_1(is_assigned: Bool, assigned_to: Plane, is_occupied: Bool, status: LocStatus) = (
	sum P: Plane . (
		receiveAssignment(gate1, P)
		. Gate_1(is_assigned = true, assigned_to = P)
	)
);

proc Gate_2(is_assigned: Bool, assigned_to: Plane, is_occupied: Bool, status: LocStatus) = (
	sum P: Plane . (
		receiveAssignment(gate2, P)
		. Gate_2(is_assigned = true, assigned_to = P)
	)
);

init allow( 
	% initial actions
	{ receiveRequest, sendResponse, assign, unassign, 
	getSensorUpdate, getLocStatus, contactHelp, commLocationStatus, 
	commAssignment, commTWSensorUpdate, commRWSensorUpdate, print },
	comm( 
		% communication
		{ 
			sendLocationStatus|receiveLocationStatus -> commLocationStatus,
			sendAssignment|receiveAssignment -> commAssignment,
			sendTWSensorUpdate|receiveTWSensorUpdate -> commTWSensorUpdate,
			sendRWSensorUpdate|receiveRWSensorUpdate -> commRWSensorUpdate
		},
		% process initialization
		Communications(lambda l: Location.operational, lambda i: Location.false)
			|| Roadway(runway, false, one, false, operational) 
			|| Roadway(taxiway, false, one, false, operational) 

			% || Taxiway(false, one, false, operational) 
			|| Gate_1(false, one, false, operational) 
			|| Gate_2(false, one, false, operational)
		%|| LocationTracking(taxiway, four)
	)
);